## API Report File for "calcium"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export interface AbstractMap<K, V> extends Iterable<[K, V]> {
    [Symbol.iterator](): IterableIterator<[K, V]>;
    clear(): void;
    delete(key: K): boolean;
    entries(): IterableIterator<[K, V]>;
    forEach(callback: (value: V, key: K, map: AbstractMap<K, V>) => void, thisArg?: any): void;
    get(key: K): V | undefined;
    has(key: K): boolean;
    keys(): IterableIterator<K>;
    set(key: K, value: V): this;
    readonly size: number;
    values(): IterableIterator<V>;
}

// @public
export interface AbstractSet<E> extends Iterable<E> {
    [Symbol.iterator](): IterableIterator<E>;
    add(element: E): this;
    clear(): void;
    delete(element: E): boolean;
    elements(): IterableIterator<E>;
    forEach(callback: (element: E, set: AbstractSet<E>) => void, thisArg?: any): void;
    has(element: E): boolean;
    readonly size: number;
}

// @public
export class BinaryHeap<T> implements Iterable<T> {
    [Symbol.iterator](): IterableIterator<T>;
    clear(): void;
    elements(): IterableIterator<T>;
    static from<T>(iterable: Iterable<T>): BinaryHeap<T>;
    peek(): T | undefined;
    pop(): T | undefined;
    push(element: T): this;
    get size(): number;
}

// @public
export interface Comparable extends Equatable {
    lessThan(rhs: this): boolean;
}

// @public
export function equality<T>(lhs: T, rhs: T): boolean;

// @public
export interface Equatable {
    equality(rhs: this): boolean;
}

// @public
export function greaterThan<T>(lhs: T, rhs: T): boolean;

// @public
export function greaterThanOrEqual<T>(lhs: T, rhs: T): boolean;

// @public
export function hash(value: unknown): number;

// @public
export interface Hashable extends Equatable {
    hash(hasher: Hasher): void;
    hashValue?: number;
}

// @public
export class Hasher {
    combine(value: unknown): void;
    finalize(): number;
}

// @public
export class HashMap<K, V> implements AbstractMap<K, V> {
    [Symbol.iterator](): IterableIterator<[K, V]>;
    constructor(initialCapacity?: number, loadFactor?: number);
    clear(): void;
    delete(key: K): boolean;
    entries(): IterableIterator<[K, V]>;
    forEach(callback: (value: V, key: K, map: HashMap<K, V>) => void, thisArg?: any): void;
    static from<K, V>(iterable: Iterable<[K, V]>): HashMap<K, V>;
    get(key: K): V | undefined;
    has(key: K): boolean;
    keys(): IterableIterator<K>;
    set(key: K, value: V): this;
    get size(): number;
    values(): IterableIterator<V>;
}

// @public
export class HashSet<E> implements AbstractSet<E> {
    [Symbol.iterator](): IterableIterator<E>;
    constructor(initialCapacity?: number, loadFactor?: number);
    add(element: E): this;
    clear(): void;
    delete(element: E): boolean;
    elements(): IterableIterator<E>;
    forEach(callback: (element: E, set: HashSet<E>) => void, thisArg?: any): void;
    static from<E>(iterable: Iterable<E>): HashSet<E>;
    has(element: E): boolean;
    get size(): number;
}

// @public
export interface Identifiable {
    readonly id: unknown;
}

// @public
export function inequality<T>(lhs: T, rhs: T): boolean;

// @public
export function lessThan<T>(lhs: T, rhs: T): boolean;

// @public
export function lessThanOrEqual<T>(lhs: T, rhs: T): boolean;

// @public
export class LinkedList<T> implements Iterable<T> {
    [Symbol.iterator](): IterableIterator<T>;
    add(element: T): this;
    append(other: LinkedList<T>): this;
    back(): T | undefined;
    clear(): void;
    delete(element: T): boolean;
    elements(): IterableIterator<T>;
    forEach(callback: (element: T, set: LinkedList<T>) => void, thisArg?: any): void;
    static from<T>(iterable: Iterable<T>): LinkedList<T>;
    front(): T | undefined;
    has(element: T): boolean;
    popBack(): T | undefined;
    popFront(): T | undefined;
    pushBack(element: T): this;
    pushFront(element: T): this;
    get size(): number;
}

// @public
export class RedBlackTree<K, V> implements AbstractMap<K, V> {
    [Symbol.iterator](): IterableIterator<[K, V]>;
    clear(): void;
    delete(key: K): boolean;
    deleteMax(): boolean;
    deleteMin(): boolean;
    entries(): IterableIterator<[K, V]>;
    forEach(callback: (value: V, key: K, map: RedBlackTree<K, V>) => void, thisArg?: any): void;
    static from<K, V>(iterable: Iterable<[K, V]>): RedBlackTree<K, V>;
    get(key: K): V | undefined;
    has(key: K): boolean;
    keys(): IterableIterator<K>;
    max(): [K, V] | null;
    min(): [K, V] | null;
    next(key: K): [K, V] | null;
    previous(key: K): [K, V] | null;
    set(key: K, value: V): this;
    get size(): number;
    values(): IterableIterator<V>;
}

```
